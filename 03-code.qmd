---
title: "Creation of annual composites in GEE"
---

## Creating an annual composite in GEE

This is the actual code that performs this. Most of the code is standard boilerplate, so it's fundamentally a "cut and paste" job, but you should change options and see the results! While all these different snippets are given individually, you should copy them **in sequence** in the code editor.

I will use using Bamako for this example, but you'll have to change this to other cities!



### Setting up some variables

It's a good idea to define options and variables once, and keep referring to them. If you want to change things later on, you can do this in a managed way.
```javascript
/**************************************************************
 * SETTINGS (you can edit these)
 **************************************************************/

// City and AOI (example: Bamako)
var cityName = 'Bamako';
var cityPoint = ee.Geometry.Point([-8.0029, 12.6392]);

// AOI size: buffer radius in metres 
var aoiRadiusMeters = 20000;

// Target years for the practical
var targetYears = [2000, 2005, 2010, 2015, 2020, 2024];

// Choose an annual period to calculate the mosaic
var seasonStartMonth = 1;  // January
var seasonEndMonth   = 4;  // April (end is handled as May 1 below)

// Scene filtering knobs (speed + robustness)
var maxCloudCoverPercent = 70; // pre-filter scenes by metadata cloud cover
var maxScenesPerYear = 25;     // keep only the clearest N scenes (big speed win)

// Visualisation stretch for reflectance RGB/false colour (scaled reflectance ~0–1)
var rgbVis = {min: 0.0, max: 0.30};
```

### Map setup

We will also select our region (simply my creating a circular buffer around the centre lat/lon of Bamako)


```javascript
/**************************************************************
 * MAP SETUP (AOI, quick sanity check)
 **************************************************************/

var aoi = cityPoint.buffer(aoiRadiusMeters); // simple circular AOI (robust geometry)

Map.centerObject(aoi, 12); // 12 is the initial zoom level
Map.addLayer(aoi, {color: 'yellow'}, cityName + ' AOI');

// AOI area sanity check (needs a small maxError)
print('AOI area (km^2):', aoi.area(1).divide(1e6));
```

### Selecting Landsat data

The following snippet selects the different Landsat collections (we need different sensors to cover our large temporal period). The Landsat L2 collection has a per pixel field callec `QA_PIXEL` that encodes whether a cloud or shadow has been detected. It also uses a dilated mask to try to mask cloud shadows. We then need to scale the data to units of reflectance (a number between 0 and 1), and additionally, we remove (mask) any pixels where the reflectance is outside this range (can happen due to to processing issues), or whether any of the bands are missing.

```javascript
/**************************************************************
 * LOAD RAW LANDSAT COLLECTIONS (Collection 2, Level-2)
 *
 * We keep these “raw” collections separate from preprocessing.
 * Important idea: filter on metadata first, then map() preprocessing.
 **************************************************************/

var landsat5_raw = ee.ImageCollection('LANDSAT/LT05/C02/T1_L2'); // Landsat 5 TM
var landsat7_raw = ee.ImageCollection('LANDSAT/LE07/C02/T1_L2'); // Landsat 7 ETM+
var landsat8_raw = ee.ImageCollection('LANDSAT/LC08/C02/T1_L2'); // Landsat 8 OLI
var landsat9_raw = ee.ImageCollection('LANDSAT/LC09/C02/T1_L2'); // Landsat 9 OLI-2


/**************************************************************
 * CLOUD/SHADOW MASKING (using QA_PIXEL)
 *
 * We use QA_PIXEL bits to remove:
 *  - Fill
 *  - Dilated cloud
 *  - Cirrus
 *  - Cloud
 *  - Cloud shadow
 *
 * This is deliberately “simple but decent” for a taster practical.
 **************************************************************/

function qaCloudShadowMask_C2L2(image) {
  var qa = image.select('QA_PIXEL');

  // Build a single-band boolean mask:
  // 1 means “keep”, 0 means “mask out”
  var mask = qa.bitwiseAnd(1 << 0).eq(0)   // not fill
    .and(qa.bitwiseAnd(1 << 1).eq(0))      // not dilated cloud
    .and(qa.bitwiseAnd(1 << 2).eq(0))      // not cirrus
    .and(qa.bitwiseAnd(1 << 3).eq(0))      // not cloud
    .and(qa.bitwiseAnd(1 << 4).eq(0));     // not cloud shadow

  return mask;
}


/**************************************************************
 * REFLECTANCE SCALING + "FEATURE HYGIENE"
 *
 * Landsat C2 L2 SR scaling:
 *   SR = DN * 0.0000275 + (-0.2)
 *
 * 
 *  - Clamp reflectance to [0, 1] to avoid odd outliers.
 *  - Mask pixels where any band is missing (edges, artefacts).
 **************************************************************/

function scaleAndCleanReflectance(srImage) {
  // Apply the scaling
  var scaled = srImage.multiply(0.0000275).add(-0.2);

  // Clamp to a sensible range
  scaled = scaled.clamp(0, 1);

  // Mask out pixels where any band is missing/invalid
  // (reduce(min) checks for missing values across bands)
  var allBandsPresent = scaled.reduce(ee.Reducer.min()).gte(0);
  return scaled.updateMask(allBandsPresent);
}
```
### Harmonise sensors

The different Landsat sensors have different band names. Here, we relabel them to a common set of names. We use the previous code snippets to apply the cloud mask, reflectance scaling and additional cleaning up to the data.

```javascript
/**************************************************************
 * SENSOR HARMONISATION (common band names)
 *
 * Landsat 5/7 SR bands: SR_B1..SR_B5, SR_B7 (Band 6 is thermal ST_B6)
 * Landsat 8/9 SR bands: SR_B2..SR_B7 (Band 1 is coastal; we ignore it)
 *
 * We rename to a common 6-band set:
 *   blue, green, red, nir, swir1, swir2
 **************************************************************/

function prepLandsat57(image) {
  var mask = qaCloudShadowMask_C2L2(image);

  var sr = image.select(
    ['SR_B1','SR_B2','SR_B3','SR_B4','SR_B5','SR_B7'],
    ['blue','green','red','nir','swir1','swir2']
  );

  var cleaned = scaleAndCleanReflectance(sr)
    .updateMask(mask)
    .copyProperties(image, image.propertyNames());

  return cleaned;
}

function prepLandsat89(image) {
  var mask = qaCloudShadowMask_C2L2(image);

  var sr = image.select(
    ['SR_B2','SR_B3','SR_B4','SR_B5','SR_B6','SR_B7'],
    ['blue','green','red','nir','swir1','swir2']
  );

  var cleaned = scaleAndCleanReflectance(sr)
    .updateMask(mask)
    .copyProperties(image, image.propertyNames());

  return cleaned;
}
```

### Add indices
In many applications, spectral band combinations can be useful to enhance the signal and facilitate classification. They're also quite useful to visually interpret images qualitatively, so we'll add a bunch of them here.


```javascript
/**************************************************************
 * ADD INDICES (extra feature bands for classification)
 *
 * Indices included:
 *  - NDVI  (vegetation)
 *  - MNDWI (water)
 *  - NDBI  (built-up proxy)
 *  - UI    (simple urban index): UI = NDBI - NDVI (easy to explain)
 *  - IBI   (index-based built-up index): contrasts built-up vs veg+water
 *  - BRIGHT (optional): mean reflectance as a simple brightness feature
 *
 * Note: There are multiple definitions in the literature;
 **************************************************************/

function safeDivide(numerator, denominator) {
  // Avoid divide-by-zero (if den == 0, set it to 1)
  denominator = denominator.where(denominator.eq(0), 1);
  return numerator.divide(denominator);
}

function addFeatureIndices(img) {
  // These assume our common bands exist: red, green, nir, swir1
  var ndvi  = img.normalizedDifference(['nir', 'red']).rename('NDVI');
  var mndwi = img.normalizedDifference(['green', 'swir1']).rename('MNDWI');
  var ndbi  = img.normalizedDifference(['swir1', 'nir']).rename('NDBI');

  // Simple urban index (teachable): built-up proxy minus vegetation
  var ui = ndbi.subtract(ndvi).rename('UI');

  // IBI (common formulation)
  var avgVegWater = ndvi.add(mndwi).divide(2);
  var ibi = safeDivide(ndbi.subtract(avgVegWater), ndbi.add(avgVegWater)).rename('IBI');

  // Brightness: average reflectance (very intuitive for students)
  var bright = img.select(['blue','green','red','nir','swir1','swir2'])
    .reduce(ee.Reducer.mean())
    .rename('BRIGHT');

  return img.addBands([ndvi, mndwi, ndbi, ui, ibi, bright]);
}
```

### Build a per year image collection

Now, all the stuff we defined above will start to get used. We need to build a stack of cleaned images per year that cover our region of interest, are masked for clouds etc. For years before 2013, we'll use Landsat 5 and 7, for years afterwards, we'll use Landsat 8 and 9. Note that we're using the variables defined at the top to control things like maximum cloud coverage etc.

```javascript
/**************************************************************
 * BUILD A PER-YEAR IMAGE COLLECTION (filter first, then map)
 *
 * Steps:
 *  - Choose a sensor group depending on year (<=2012 uses L5+L7; >=2013 uses L8+L9)
 *  - Filter by AOI and dry-season date window
 *  - Filter by CLOUD_COVER metadata, sort clearest-first, keep top N scenes
 *  - Map preprocessing (mask + scale + rename bands)
 **************************************************************/

function getSeasonDateRange(year) {
  year = ee.Number(year);

  var start = ee.Date.fromYMD(year, seasonStartMonth, 1);

  // endMonth is inclusive-ish: we use the first day of the next month as end
  var end = ee.Date.fromYMD(year, seasonEndMonth + 1, 1);

  return {start: start, end: end};
}

function collectionForYear(year) {
  year = ee.Number(year);
  var range = getSeasonDateRange(year);

  // Choose sensors based on era
  var rawCollection = ee.ImageCollection(
    ee.Algorithms.If(
      year.lte(2012),
      landsat5_raw.merge(landsat7_raw),   // 2000–2012 era
      landsat8_raw.merge(landsat9_raw)    // 2013+ era
    )
  );

  // Filter on raw metadata BEFORE preprocessing
  var filtered = rawCollection
    .filterBounds(aoi)
    .filterDate(range.start, range.end)
    .filterMetadata('CLOUD_COVER', 'less_than', maxCloudCoverPercent)
    .sort('CLOUD_COVER')
    .limit(maxScenesPerYear);

  // Now map preprocessing and band harmonisation
  var prepped = ee.ImageCollection(
    ee.Algorithms.If(
      year.lte(2012),
      filtered.map(prepLandsat57),
      filtered.map(prepLandsat89)
    )
  );

  return prepped;
}
```

### The annual composite!

You thought we'd never get here! The next bit defines how the composite gets done (using the median), adds the relevant indices and applies it to all the years.

```javascript
/**************************************************************
 * ANNUAL COMPOSITE (median) + indices
 *
 * The “annual mosaic” is the median of all (masked) images in the season.
 * Then we add indices so the final image is ready for classification.
 **************************************************************/

function annualComposite(year) {
  year = ee.Number(year);

  var col = collectionForYear(year);

  // Diagnostics: useful for teaching and debugging
  print('Year', year, 'images used:', col.size());

  // Build the composite and add feature indices
  var composite = addFeatureIndices(col.median())
    .clip(aoi)
    .set('year', year)
    // time_start used later if we chart time series
    .set('system:time_start', ee.Date.fromYMD(year, 3, 1).millis());

  return composite;
}

// Build mosaics for all target years
var annualMosaics = ee.ImageCollection(targetYears.map(annualComposite));
print('Annual mosaics:', annualMosaics);
```

### Display the composite

```javascript
/**************************************************************
 * DISPLAY (choose one year to show)
 *
 * Show:
 *  - RGB (natural colour)
 *  - False colour (NIR / red / green) helps see vegetation strongly
 *  - Indices (NDVI, MNDWI, NDBI, UI, IBI)
 *
 * Note: we use visualize() for the RGB layers because it makes map
 * rendering snappier in the Code Editor.
 **************************************************************/

var displayYear = 2020;
var mosaicToShow = ee.Image(
  annualMosaics.filter(ee.Filter.eq('year', displayYear)).first()
);

// Always sanity-check the bands (helpful if something returns empty)
print('Bands in displayed mosaic:', mosaicToShow.bandNames());

// RGB and false colour previews
Map.addLayer(
  mosaicToShow.select(['red','green','blue']).visualize(rgbVis),
  {},
  'RGB ' + displayYear
);

Map.addLayer(
  mosaicToShow.select(['nir','red','green']).visualize(rgbVis),
  {},
  'False colour (NIR/R/G) ' + displayYear
);

// Index layers (simple min/max for teaching; no palettes needed)
Map.addLayer(mosaicToShow.select('NDVI'),  {min: -0.2, max: 0.8}, 'NDVI');
Map.addLayer(mosaicToShow.select('MNDWI'), {min: -0.6, max: 0.6}, 'MNDWI');
Map.addLayer(mosaicToShow.select('NDBI'),  {min: -0.6, max: 0.6}, 'NDBI');
Map.addLayer(mosaicToShow.select('UI'),    {min: -1.0, max: 1.0}, 'UI (= NDBI - NDVI)');
Map.addLayer(mosaicToShow.select('IBI'),   {min: -1.0, max: 1.0}, 'IBI');
Map.addLayer(mosaicToShow.select('BRIGHT'),{min: 0.0,  max: 0.4}, 'Brightness');

```

### Export sample display year GeoTIFF to Google Drive

For repeatibility and further analysis, we'll export the data to your Google Drive. We'll use the standard GeoTIFF format, with internal compression to make the data more manageable. This snippet exports a single year, make sure you're happy with it before exporting all the years.
```javascript
/**************************************************************
 * EXPORT ONE YEAR MOSAIC TO GOOGLE DRIVE
 *
 * Pattern:
 *  - Export ONE year first (students learn exports without waiting ages)
 *  - Later, export all years or the classification outputs
 **************************************************************/

// Uncomment to export the displayed year mosaic (multiband)
 
Export.image.toDrive({
  image: mosaicToShow, // includes SR bands + indices
  description: cityName + '_Mosaic_' + displayYear,
  folder: 'GEE_exports',
  fileNamePrefix: cityName + '_Mosaic_' + displayYear,
  region: aoi,
  scale: 30,
  maxPixels: 1e13,
  fileFormat: 'GeoTIFF',
  formatOptions: {
    cloudOptimized: true,   // Makes it a COG
    compression: 'DEFLATE' // Powerful lossless compression
  }
});



```

### Export all the years

Once you're happy with the single year export, it's time to expoert all the years in one go.

```javascript
/**************************************************************
 * EXPORT ALL YEARS (one multiband GeoTIFF per year)
 * - Exports each annual mosaic (SR bands + indices) to Google Drive
 * - GeoTIFF options: cloud-optimised (COG) + DEFLATE compression
 **************************************************************/

// Folder in Google Drive
var exportFolder = 'GEE_exports';

// Choose a scale appropriate for Landsat SR
var exportScale = 30;

// Loop over years and create one export task per year
targetYears.forEach(function(year) {

  var img = ee.Image(
    annualMosaics.filter(ee.Filter.eq('year', year)).first()
  );

  Export.image.toDrive({
    image: img,                       // multiband: SR + indices
    description: cityName + '_Mosaic_' + year,
    folder: exportFolder,
    fileNamePrefix: cityName + '_Mosaic_' + year,
    region: aoi,
    scale: exportScale,
    maxPixels: 1e13,
    fileFormat: 'GeoTIFF',
    formatOptions: {
      cloudOptimized: true,
      compression: 'DEFLATE'
    }
  });

});
```

### Exporting annual mosaics as Earth Engine Assets

So far, we have used Google Earth Engine to build annual mosaics for our city of interest. These mosaics exist only temporarily inside the script unless we explicitly save them. In addition to exporting images to Google Drive, Earth Engine allows us to export data as Assets, which are stored permanently within our Earth Engine account. Saving the mosaics as Assets is  useful because they can be imported directly into other scripts without re-running the mosaicking workflow, making it easier to separate data preparation from later analysis steps such as classification or time-series analysis.

To export an annual mosaic as an Asset, we select one of the mosaics from our `annualMosaics` ImageCollection and use `Export.image.toAsset()`. When doing this, we must specify:

* an asset ID, which defines where the image will be stored in our Earth Engine Assets,
* the region to export (our AOI),
* the spatial resolution (30 m for Landsat data).

The example below exports the mosaic for a single year. Once the export task has completed, the image will appear in the Assets tab of the Earth Engine Code Editor and can be loaded in other scripts using its asset path.

```javascript
// Select the mosaic for the year we want to export
var exportYear = 2020;

var mosaicToExport = ee.Image(
  annualMosaics.filter(ee.Filter.eq('year', exportYear)).first()
);

// Export the mosaic as a Google Earth Engine Asset
Export.image.toAsset({
  image: mosaicToExport,                 // multiband image (SR + indices)
  description: cityName + '_Mosaic_' + exportYear,
  assetId: 'users/YOUR_USERNAME/' + cityName + '_Mosaic_' + exportYear,
  region: aoi,
  scale: 30,
  maxPixels: 1e13
}); // Change YOUR_USERNAME with your own GEE username!
```
::: {.callout-warning}

After starting the export, the task will appear in the Tasks tab of the Code Editor. **You must manually click Run to begin the export**. When it has finished, the mosaic can be reused in other Earth Engine scripts by loading it from the Assets panel, allowing you to work directly with the prepared annual composites without repeating the earlier processing steps.

:::

